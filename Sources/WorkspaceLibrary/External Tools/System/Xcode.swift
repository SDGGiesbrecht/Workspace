/*
 Xcode.swift

 This source file is part of the Workspace open source project.
 https://github.com/SDGGiesbrecht/Workspace#workspace

 Copyright ©2017–2018 Jeremy David Giesbrecht and the Workspace project contributors.

 Soli Deo gloria.

 Licensed under the Apache Licence, Version 2.0.
 See http://www.apache.org/licenses/LICENSE-2.0 for licence information.
 */

#if !os(Linux)

    import Foundation

    import SDGCornerstone
    import SDGCommandLine

    typealias Xcode = _Xcode // Shared from SDGCommandLine.
    extension Xcode {

        // MARK: - Static Properties

        static let defaultVersion = Version(9, 3)
        static let `default` = Xcode(version: defaultVersion)

        // MARK: - Initialization

        convenience init(version: Version) {
            self.init(_version: version)
        }

        // MARK: - Usage

        private func parseError(projectInformation: String) -> Command.Error { // [_Exempt from Test Coverage_] Reachable only with an incompatible version of Xcode.
            return Command.Error(description: UserFacingText<InterfaceLocalization>({ (localization) in // [_Exempt from Test Coverage_]
                switch localization {
                case .englishCanada: // [_Exempt from Test Coverage_]
                    return StrictString("Error loading Xcode project:\n\(projectInformation)")
                }
            }))
        }

        func projectFile() throws -> URL? { // [_Exempt from Test Coverage_] [_Workaround: Until refresh Xcode project is testable._]
            let files = try FileManager.default.contentsOfDirectory(at: URL(fileURLWithPath: FileManager.default.currentDirectoryPath), includingPropertiesForKeys: [], options: [])

            for file in files where file.pathExtension == "xcodeproj" { // [_Exempt from Test Coverage_] [_Workaround: Until refresh Xcode project is testable._]
                return file
            } // [_Exempt from Test Coverage_] [_Workaround: Until refresh Xcode project is testable._]

            return nil
        }

        func scheme(output: inout Command.Output) throws -> String {
            let information = try executeInCompatibilityMode(with: ["\u{2D}list"], output: &output, silently: true)

            guard let schemesHeader = information.scalars.firstMatch(for: "Schemes:".scalars)?.range else { // [_Exempt from Test Coverage_] Reachable only with an incompatible version of Xcode.
                throw parseError(projectInformation: information)
            }
            var lineLocation = schemesHeader.lines(in: information.lines).upperBound

            var name: String? = nil
            while name == nil {
                guard lineLocation ≠ information.lines.endIndex else { // [_Exempt from Test Coverage_] Reachable only with an incompatible version of Xcode.
                    throw parseError(projectInformation: information)
                }
                let line = information.lines[lineLocation].line
                let nameOnly = String(line.filter({ $0 ∉ CharacterSet.whitespaces }))
                if nameOnly.hasSuffix("\u{2D}Package") {
                    name = nameOnly
                } else {
                    lineLocation = information.lines.index(after: lineLocation)
                }
            }
            return name!
        }

        enum SDK : String {
            case macOS = "macosx"
            case iOS = "iphoneos"
            case iOSSimulator = "iphonesimulator"
            case watchOS = "watchos"
            case tvOS = "appletvos"
            case tvOSSimulator = "appletvsimulator"
        }

        func build(scheme: String, for sdk: SDK, output: inout Command.Output) throws -> Bool {

            let log = try executeInCompatibilityMode(with: [
                "build",
                "\u{2D}sdk", sdk.rawValue,
                "\u{2D}scheme", scheme
                ], output: &output)

            let warnings = log.scalars.matches(for: " warning:".scalars).filter { match in // [_Exempt from Test Coverage_] Only triggered on the first build.

                return ¬log.scalars[match.range.upperBound...].hasPrefix(" directory not found for option \u{27}\u{2D}F/Applications/Xcode".scalars)
                // The above false positive occurs when a project generated by the Swift Package Manager attempts to build for watchOS.
            }

            return warnings.isEmpty
        }

        private func buildSettings(for scheme: String, on sdk: SDK, output: inout Command.Output) throws -> String {
            return try executeInCompatibilityMode(with: [
                "\u{2D}showBuildSettings",
                "\u{2D}scheme", scheme,
                "\u{2D}sdk", sdk.rawValue
                ], output: &output, silently: true)
        }

        private func buildDirectory(for scheme: String, on sdk: SDK, output: inout Command.Output) throws -> URL {
            let settings = try buildSettings(for: scheme, on: sdk, output: &output)
            guard let productDirectory = settings.scalars.firstNestingLevel(startingWith: " BUILD_DIR = ".scalars, endingWith: "\n".scalars)?.contents.contents else { // [_Exempt from Test Coverage_] Unreachable without corrupt project.
                throw Command.Error(description: UserFacingText({(localization: InterfaceLocalization) in // [_Exempt from Test Coverage_]
                    switch localization {
                    case .englishCanada: // [_Exempt from Test Coverage_]
                        return "Could not find “BUILD_DIR” in Xcode build settings."
                    }
                }))
            }
            return URL(fileURLWithPath: String(productDirectory)).deletingLastPathComponent()
        }

        private func productsDirectory(for scheme: String, on sdk: SDK, output: inout Command.Output) throws -> URL {
            return try buildDirectory(for: scheme, on: sdk, output: &output).appendingPathComponent("Products")
        }

        private func coverageDirectory(for scheme: String, on sdk: SDK, output: inout Command.Output) throws -> URL {
            return try buildDirectory(for: scheme, on: sdk, output: &output).appendingPathComponent("ProfileData")
        }

        func test(scheme: String, on sdk: SDK, output: inout Command.Output) -> Bool {

            if let coverage = try? coverageDirectory(for: scheme, on: sdk, output: &output) {
                try? FileManager.default.removeItem(at: coverage)
            }

            var script = [
                "test"
            ]

            switch sdk {
            case .iOSSimulator: // [_Exempt from Test Coverage_] Tested separately.
                script += ["\u{2D}destination", "name=iPhone 8"]
            case .tvOSSimulator: // [_Exempt from Test Coverage_] Tested separately.
                script += ["\u{2D}destination", "name=Apple TV 4K"]
            default:
                script += ["\u{2D}sdk", sdk.rawValue]
            }

            script += ["\u{2D}scheme", scheme]

            do {
                _ = try executeInCompatibilityMode(with: script, output: &output)
                return true
            } catch {
                return false
            }
        }

        func coverageData(for target: String, of scheme: String, on sdk: SDK, output: inout Command.Output) throws -> String {

            let directory = try coverageDirectory(for: scheme, on: sdk, output: &output)
            guard let instance = try FileManager.default.contentsOfDirectory(at: directory, includingPropertiesForKeys: nil, options: []).first else { // [_Exempt from Test Coverage_] Unreachable without corrupt project.
                throw Command.Error(description: UserFacingText({(localization: InterfaceLocalization) in // [_Exempt from Test Coverage_]
                    switch localization {
                    case .englishCanada: // [_Exempt from Test Coverage_]
                        return "No coverage data available."
                    }
                }))
            }
            let rawData = instance.appendingPathComponent("Coverage.profdata")

            let settings = try buildSettings(for: scheme, on: sdk, output: &output)
            guard let executablePathSuffix = settings.scalars.firstNestingLevel(startingWith: " EXECUTABLE_PATH = \(target).".scalars, endingWith: "\n".scalars)?.contents.contents else { // [_Exempt from Test Coverage_] Unreachable without corrupt project.
                throw Command.Error(description: UserFacingText({(localization: InterfaceLocalization) in // [_Exempt from Test Coverage_]
                    switch localization {
                    case .englishCanada: // [_Exempt from Test Coverage_]
                        return "Could not find “EXECUTABLE_PATH” in Xcode build settings."
                    }
                }))
            }
            let relativeExecutableLocation = target + "." + String(executablePathSuffix)

            let directorySuffix: String
            if sdk == .macOS {
                directorySuffix = ""
            } else { // [_Exempt from Test Coverage_] Tested separately.
                directorySuffix = "\u{2D}" + sdk.rawValue
            }

            let executable = try productsDirectory(for: scheme, on: sdk, output: &output).appendingPathComponent("Debug" + directorySuffix).appendingPathComponent(relativeExecutableLocation)

            return try Shell.default.run(command: [
                "xcrun", "llvm\u{2D}cov", "show",
                "\u{2D}show\u{2D}regions",
                "\u{2D}instr\u{2D}profile",
                rawData.path,
                executable.path
                ])
        }
    }

#endif
